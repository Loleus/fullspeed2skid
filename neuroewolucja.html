





<!-- 
<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Prosta sieć neuronowa: neuroewolucja w labiryncie</title>
  <style>
    body { font-family: system-ui, sans-serif; background:#111; color:#eee; display:flex; gap:24px; }
    #ui { width: 300px; }
    canvas { background:#222; border:1px solid #444; }
    .pill { background:#333; padding:6px 10px; border-radius:6px; display:inline-block; margin-right:8px; }
    label { display:block; margin:8px 0 4px; font-size:14px; color:#ccc; }
    input[type=range] { width:100%; }
    button { padding:8px 12px; background:#444; color:#eee; border:none; cursor:pointer; }
    button:hover { background:#555; }
  </style>
</head>
<body>
  <div id="ui">
    <h2>NN sterująca kropkami</h2>
    <div><span class="pill">Populacja: <b id="pop">100</b></span><span class="pill">Generacja: <b id="gen">0</b></span></div>
    <div><span class="pill">Najlepszy fitness: <b id="best">0</b></span></div>

    <label>Warstwa ukryta (neurony)</label>
    <input id="hidden" type="range" min="2" max="24" value="8">
    <div>Wartość: <b id="hiddenVal">8</b></div>

    <label>Mutacja wag (%)</label>
    <input id="mutRate" type="range" min="0" max="20" value="8">
    <div>Wartość: <b id="mutRateVal">8%</b></div>

    <label>Elitaryzm</label>
    <input id="elite" type="range" min="1" max="20" value="5">
    <div>Wartość: <b id="eliteVal">5</b></div>

    <div style="margin-top:12px;">
      <button id="restart">Restart</button>
      <button id="pause">Pauza</button>
    </div>

    <p style="margin-top:12px; color:#aaa;">
      Wejścia: dystanse do ścian (góra/dół/lewo/prawo) oraz wektor do celu. Wyjścia: dx, dy (tanh).
      Uczenie: neuroewolucja – selekcja, krzyżowanie i mutacja wag.
    </p>
  </div>

  <canvas id="cv" width="720" height="520"></canvas>

  <script>
    // --- Parametry ---
    const W = 720, H = 520;
    const POP_SIZE = 100;
    let HIDDEN = 8;
    let MUT_RATE = 0.08;
    let ELITE_COUNT = 5;
    const STEP_LIMIT = 1200;
    const SPEED = 1.8;

    const start = { x: 50, y: H - 50 };
    const goal  = { x: W - 70, y: 60, r: 18 };

    const cv = document.getElementById('cv');
    const ctx = cv.getContext('2d');

    const popEl = document.getElementById('pop');
    const genEl = document.getElementById('gen');
    const bestEl = document.getElementById('best');
    const hiddenEl = document.getElementById('hidden');
    const hiddenValEl = document.getElementById('hiddenVal');
    const mutRateEl = document.getElementById('mutRate');
    const mutRateValEl = document.getElementById('mutRateVal');
    const eliteEl = document.getElementById('elite');
    const eliteValEl = document.getElementById('eliteVal');
    const btnRestart = document.getElementById('restart');
    const btnPause = document.getElementById('pause');

    popEl.textContent = POP_SIZE;
    hiddenEl.oninput = () => { HIDDEN = +hiddenEl.value; hiddenValEl.textContent = HIDDEN; resetPopulation(true); };
    mutRateEl.oninput = () => { MUT_RATE = +mutRateEl.value/100; mutRateValEl.textContent = Math.round(MUT_RATE*100)+'%'; };
    eliteEl.oninput = () => { ELITE_COUNT = +eliteEl.value; eliteValEl.textContent = ELITE_COUNT; };
    btnRestart.onclick = () => resetPopulation(true);
    let paused = false;
    btnPause.onclick = () => { paused = !paused; btnPause.textContent = paused ? 'Wznów' : 'Pauza'; };

    // --- Labirynt (ten sam co wcześniej) ---
    const walls = [
      {x: 0, y: 0, w: W, h: 20},
      {x: 0, y: H-20, w: W, h: 20},
      {x: 0, y: 0, w: 20, h: H},
      {x: W-20, y: 0, w: 20, h: H},

      {x: 120, y: 80, w: 480, h: 20},
      {x: 120, y: 80, w: 20, h: 300},
      {x: 120, y: 360, w: 400, h: 20},
      {x: 500, y: 140, w: 20, h: 240},
      {x: 260, y: 140, w: 260, h: 20},
      {x: 260, y: 200, w: 20, h: 160},
      {x: 320, y: 260, w: 180, h: 20},
    ];

    function drawMaze() {
      ctx.fillStyle = '#333';
      ctx.fillRect(0,0,W,H);

      ctx.beginPath();
      ctx.fillStyle = '#2ecc71';
      ctx.arc(goal.x, goal.y, goal.r, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = '#3498db';
      ctx.arc(start.x, start.y, 6, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = '#777';
      for (const w of walls) ctx.fillRect(w.x, w.y, w.w, w.h);
    }

    function collides(x, y, r=3) {
      for (const w of walls) {
        const nx = Math.max(w.x, Math.min(x, w.x + w.w));
        const ny = Math.max(w.y, Math.min(y, w.y + w.h));
        const dx = x - nx, dy = y - ny;
        if (dx*dx + dy*dy <= r*r) return true;
      }
      if (x < 20+r || x > W-20-r || y < 20+r || y > H-20-r) return true;
      return false;
    }

    // --- Prosta sieć: wejścia(6) -> hidden(H) -> wyjścia(2) z tanh ---
    function randn() {
      // Box-Muller
      const u = Math.random(), v = Math.random();
      return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
    }

    class Net {
      constructor(inDim=6, hiddenDim=HIDDEN, outDim=2, weights=null) {
        this.inDim = inDim; this.hiddenDim = hiddenDim; this.outDim = outDim;
        if (weights) {
          this.W1 = weights.W1; this.b1 = weights.b1;
          this.W2 = weights.W2; this.b2 = weights.b2;
        } else {
          // inicjalizacja He/Xavier uproszczona
          this.W1 = Array.from({length: hiddenDim}, ()=> Array.from({length: inDim}, ()=> randn()*0.3));
          this.b1 = Array.from({length: hiddenDim}, ()=> 0);
          this.W2 = Array.from({length: outDim}, ()=> Array.from({length: hiddenDim}, ()=> randn()*0.3));
          this.b2 = Array.from({length: outDim}, ()=> 0);
        }
      }
      forward(x) {
        const h = new Array(this.hiddenDim).fill(0);
        for (let i=0;i<this.hiddenDim;i++) {
          let s = this.b1[i];
          for (let j=0;j<this.inDim;j++) s += this.W1[i][j]*x[j];
          // ReLU
          h[i] = s > 0 ? s : 0;
        }
        const y = new Array(this.outDim).fill(0);
        for (let i=0;i<this.outDim;i++) {
          let s = this.b2[i];
          for (let j=0;j<this.hiddenDim;j++) s += this.W2[i][j]*h[j];
          // tanh ogranicza dx, dy do [-1,1]
          y[i] = Math.tanh(s);
        }
        return y;
      }
      copyWeights() {
        return {
          W1: this.W1.map(row=> [...row]),
          b1: [...this.b1],
          W2: this.W2.map(row=> [...row]),
          b2: [...this.b2],
        };
      }
    }

    // --- Sensory: dystans do ścian w 4 kierunkach + wektor do celu (znormalizowany) ---
    function rayDistance(x, y, dir) {
      const step = 3;
      let d = 0;
      let cx = x, cy = y;
      for (let k=0;k<500;k++) {
        cx += dir[0]*step; cy += dir[1]*step; d += step;
        if (collides(cx, cy)) break;
      }
      // normalizacja do [0,1] względem max 500*step
      return Math.min(1, d / (500*step));
    }

    function sensors(ax, ay) {
      const up = rayDistance(ax, ay, [0,-1]);
      const down = rayDistance(ax, ay, [0, 1]);
      const left = rayDistance(ax, ay, [-1,0]);
      const right = rayDistance(ax, ay, [1, 0]);
      const vx = goal.x - ax, vy = goal.y - ay;
      const norm = Math.sqrt(vx*vx + vy*vy) + 1e-6;
      const gx = vx / norm, gy = vy / norm;
      return [up, down, left, right, gx, gy];
    }

    // --- Agent z siecią ---
    class Agent {
      constructor(net=null) {
        this.x = start.x;
        this.y = start.y;
        this.r = 3;
        this.dead = false;
        this.reached = false;
        this.step = 0;
        this.net = net || new Net();
        this.fitness = 0;
      }
      update() {
        if (this.dead || this.reached) return;
        if (this.step++ > STEP_LIMIT) { this.dead = true; return; }

        const s = sensors(this.x, this.y);
        const out = this.net.forward(s);
        const nx = this.x + out[0]*SPEED;
        const ny = this.y + out[1]*SPEED;

        if (collides(nx, ny, this.r)) {
          this.dead = true; return;
        }
        this.x = nx; this.y = ny;

        const dx = this.x - goal.x, dy = this.y - goal.y;
        if (dx*dx + dy*dy <= goal.r*goal.r) this.reached = true;
      }
      computeFitness() {
        const dx = this.x - goal.x, dy = this.y - goal.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const base = 1/(dist+1e-6);
        const reachedBonus = this.reached ? 10 : 0;
        const aliveBonus = this.dead ? 0 : 0.2;
        this.fitness = base + reachedBonus + aliveBonus;
        return this.fitness;
      }
      draw() {
        ctx.beginPath();
        ctx.fillStyle = this.reached ? '#2ecc71' : (this.dead ? '#aa4444' : '#e0e0e0');
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // --- Populacja i ewolucja wag NN ---
    let population = [];
    let generation = 0;
    let bestFitness = 0;

    function resetPopulation(hard=false) {
      if (hard) generation = 0;
      population = new Array(POP_SIZE).fill(0).map(()=> new Agent(new Net(6, HIDDEN, 2)));
      bestFitness = 0;
      genEl.textContent = generation;
      bestEl.textContent = bestFitness.toFixed(3);
    }
    resetPopulation();

    function evolve() {
      let totalFit = 0, best = null;
      for (const a of population) {
        const f = a.computeFitness();
        totalFit += f;
        if (!best || f > best.fitness) best = a;
      }
      bestFitness = best.fitness;
      bestEl.textContent = bestFitness.toFixed(3);

      const sorted = [...population].sort((a,b)=> b.fitness - a.fitness);
      const next = [];

      // elita
      for (let i=0;i<ELITE_COUNT;i++) {
        const w = sorted[i].net.copyWeights();
        next.push(new Agent(new Net(6, HIDDEN, 2, w)));
      }

      function pick() {
        const r = Math.random()*totalFit;
        let acc = 0;
        for (const a of population) {
          acc += a.fitness; if (acc >= r) return a;
        }
        return population[population.length-1];
      }

      while (next.length < POP_SIZE) {
        const p1 = pick(), p2 = pick();
        const childW = crossoverWeights(p1.net.copyWeights(), p2.net.copyWeights());
        mutateWeights(childW);
        next.push(new Agent(new Net(6, HIDDEN, 2, childW)));
      }

      population = next;
      generation++;
      genEl.textContent = generation;
    }

    function crossoverWeights(w1, w2) {
      function mixMat(A, B) {
        return A.map((row, i)=> row.map((v, j)=> (Math.random()<0.5 ? v : B[i][j])));
      }
      function mixVec(a, b) {
        return a.map((v, i)=> (Math.random()<0.5 ? v : b[i]));
      }
      return {
        W1: mixMat(w1.W1, w2.W1),
        b1: mixVec(w1.b1, w2.b1),
        W2: mixMat(w1.W2, w2.W2),
        b2: mixVec(w1.b2, w2.b2),
      };
    }

    function mutateWeights(w) {
      function mutMat(M) {
        for (let i=0;i<M.length;i++) {
          for (let j=0;j<M[i].length;j++) {
            if (Math.random() < MUT_RATE) {
              M[i][j] += randn()*0.2; // mała gaussowska perturbacja
            }
          }
        }
      }
      function mutVec(v) {
        for (let i=0;i<v.length;i++) {
          if (Math.random() < MUT_RATE) v[i] += randn()*0.2;
        }
      }
      mutMat(w.W1); mutVec(w.b1);
      mutMat(w.W2); mutVec(w.b2);
    }

    // --- Pętla ---
    let t = 0;
    function loop() {
      drawMaze();
      for (const a of population) {
        if (!paused) a.update();
        a.draw();
      }
      if (!paused) {
        t++;
        // gdy wszyscy martwi albo osiągnięto limit kroków -> ewolucja
        const allDone = population.every(a=> a.dead || a.reached) || t >= STEP_LIMIT;
        if (allDone) {
          evolve();
          t = 0;
          for (const a of population) { a.step = 0; a.dead = false; a.reached = false; a.x = start.x; a.y = start.y; }
        }
      }
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html> -->








<!-- 




<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Q-learning: 100 kropek w labiryncie</title>
  <style>
    body { font-family: system-ui, sans-serif; background:#111; color:#eee; display:flex; gap:24px; }
    #ui { width: 320px; }
    canvas { background:#222; border:1px solid #444; }
    .pill { background:#333; padding:6px 10px; border-radius:6px; display:inline-block; margin-right:8px; }
    label { display:block; margin:8px 0 4px; font-size:14px; color:#ccc; }
    input[type=range] { width:100%; }
    button { padding:8px 12px; background:#444; color:#eee; border:none; cursor:pointer; }
    button:hover { background:#555; }
    .hint { color:#aaa; font-size:13px; }
  </style>
</head>
<body>
  <div id="ui">
    <h2>Q-learning w labiryncie</h2>
    <div><span class="pill">Populacja: <b id="pop">100</b></span><span class="pill">Epizod: <b id="epi">0</b></span></div>
    <div><span class="pill">Epsilon: <b id="eps">0.30</b></span><span class="pill">Najlepszy czas: <b id="best">—</b></span></div>

    <label>Rozmiar komórki siatki (px)</label>
    <input id="cellSize" type="range" min="10" max="40" value="20">
    <div>Wartość: <b id="cellSizeVal">20</b></div>

    <label>Uczenie (alpha)</label>
    <input id="alpha" type="range" min="1" max="100" value="25">
    <div>Wartość: <b id="alphaVal">0.25</b></div>

    <label>Zdyskontowanie (gamma)</label>
    <input id="gamma" type="range" min="50" max="99" value="92">
    <div>Wartość: <b id="gammaVal">0.92</b></div>

    <label>Epsilon początkowy</label>
    <input id="epsInit" type="range" min="0" max="100" value="30">
    <div>Wartość: <b id="epsInitVal">0.30</b></div>

    <label>Spadek eps po epizodzie</label>
    <input id="epsDecay" type="range" min="90" max="100" value="98">
    <div>Wartość: <b id="epsDecayVal">0.98</b> <span class="hint">(mnożnik)</span></div>

    <label>Kary/nagrody</label>
    <div class="hint">Krok: -0.001, ściana: -1.0, cel: +10.0</div>

    <div style="margin-top:12px;">
      <button id="restart">Restart</button>
      <button id="pause">Pauza</button>
      <button id="clearQ">Wyczyść Q</button>
    </div>

    <p class="hint" style="margin-top:12px;">
      Stany: pozycja na siatce. Akcje: góra/dół/lewo/prawo. Epsilon-greedy z malejącym epsilonem.
      Kropki giną przy kontakcie ze ścianą. Wspólna tablica Q uczy się z doświadczeń wszystkich.
    </p>
  </div>

  <canvas id="cv" width="720" height="520"></canvas>

  <script>
    // --- Parametry ogólne ---
    const W = 720, H = 520;
    const POP_SIZE = 100;
    const SPEED = 2.0;
    const STEP_LIMIT = 2000;

    const start = { x: 50, y: H - 50 };
    const goal  = { x: W - 70, y: 60, r: 18 };

    const cv = document.getElementById('cv');
    const ctx = cv.getContext('2d');

    const epiEl = document.getElementById('epi');
    const popEl = document.getElementById('pop');
    const epsEl = document.getElementById('eps');
    const bestEl = document.getElementById('best');
    const cellSizeEl = document.getElementById('cellSize');
    const cellSizeValEl = document.getElementById('cellSizeVal');
    const alphaEl = document.getElementById('alpha');
    const alphaValEl = document.getElementById('alphaVal');
    const gammaEl = document.getElementById('gamma');
    const gammaValEl = document.getElementById('gammaVal');
    const epsInitEl = document.getElementById('epsInit');
    const epsInitValEl = document.getElementById('epsInitVal');
    const epsDecayEl = document.getElementById('epsDecay');
    const epsDecayValEl = document.getElementById('epsDecayVal');

    const btnRestart = document.getElementById('restart');
    const btnPause   = document.getElementById('pause');
    const btnClearQ  = document.getElementById('clearQ');

    popEl.textContent = POP_SIZE;

    let CELL = +cellSizeEl.value;
    let ALPHA = +alphaEl.value / 100;
    let GAMMA = +gammaEl.value / 100;
    let EPS = +epsInitEl.value / 100;
    let EPS_DECAY = +epsDecayEl.value / 100;

    cellSizeValEl.textContent = CELL;
    alphaValEl.textContent = ALPHA.toFixed(2);
    gammaValEl.textContent = GAMMA.toFixed(2);
    epsInitValEl.textContent = EPS.toFixed(2);
    eps_decay_display();
    function eps_decay_display(){ epsDecayValEl.textContent = EPS_DECAY.toFixed(2); epsEl.textContent = EPS.toFixed(2); }

    cellSizeEl.oninput = () => { CELL = +cellSizeEl.value; cellSizeValEl.textContent = CELL; };
    alphaEl.oninput = () => { ALPHA = +alphaEl.value/100; alphaValEl.textContent = ALPHA.toFixed(2); };
    gammaEl.oninput = () => { GAMMA = +gammaEl.value/100; gammaValEl.textContent = GAMMA.toFixed(2); };
    epsInitEl.oninput = () => { EPS = +epsInitEl.value/100; epsInitValEl.textContent = EPS.toFixed(2); eps_decay_display(); };
    epsDecayEl.oninput = () => { EPS_DECAY = +epsDecayEl.value/100; eps_decay_display(); };

    btnClearQ.onclick = () => { Q.clear(); };
    btnRestart.onclick = () => { resetAgents(true); EPS = +epsInitEl.value/100; eps_decay_display(); };
    let paused = false;
    btnPause.onclick = () => { paused = !paused; btnPause.textContent = paused ? 'Wznów' : 'Pauza'; };

    // --- Labirynt: ściany ---
    const walls = [
      {x: 0, y: 0, w: W, h: 20},
      {x: 0, y: H-20, w: W, h: 20},
      {x: 0, y: 0, w: 20, h: H},
      {x: W-20, y: 0, w: 20, h: H},

      {x: 120, y: 80, w: 480, h: 20},
      {x: 120, y: 80, w: 20, h: 300},
      {x: 120, y: 360, w: 400, h: 20},
      {x: 500, y: 140, w: 20, h: 240},
      {x: 260, y: 140, w: 260, h: 20},
      {x: 260, y: 200, w: 20, h: 160},
      {x: 320, y: 260, w: 180, h: 20},
    ];

    function drawMaze() {
      ctx.fillStyle = '#333';
      ctx.fillRect(0,0,W,H);

      // goal
      ctx.beginPath();
      ctx.fillStyle = '#2ecc71';
      ctx.arc(goal.x, goal.y, goal.r, 0, Math.PI*2);
      ctx.fill();

      // start
      ctx.beginPath();
      ctx.fillStyle = '#3498db';
      ctx.arc(start.x, start.y, 6, 0, Math.PI*2);
      ctx.fill();

      // walls
      ctx.fillStyle = '#777';
      for (const w of walls) ctx.fillRect(w.x, w.y, w.w, w.h);

      // grid overlay (opcjonalnie)
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      for (let x=20; x<=W-20; x+=CELL) { ctx.beginPath(); ctx.moveTo(x,20); ctx.lineTo(x,H-20); ctx.stroke(); }
      for (let y=20; y<=H-20; y+=CELL) { ctx.beginPath(); ctx.moveTo(20,y); ctx.lineTo(W-20,y); ctx.stroke(); }
    }

    function collides(x, y, r=3) {
      for (const w of walls) {
        const nx = Math.max(w.x, Math.min(x, w.x + w.w));
        const ny = Math.max(w.y, Math.min(y, w.y + w.h));
        const dx = x - nx, dy = y - ny;
        if (dx*dx + dy*dy <= r*r) return true;
      }
      if (x < 20+r || x > W-20-r || y < 20+r || y > H-20-r) return true;
      return false;
    }

    // --- Dyskretyzacja stanu (siatka) ---
    function toCell(x, y) {
      // ogranicz do wewnętrznej przestrzeni (bez ramki 20px)
      const gx = Math.max(20, Math.min(x, W-20-1));
      const gy = Math.max(20, Math.min(y, H-20-1));
      const cx = Math.floor((gx-20) / CELL);
      const cy = Math.floor((gy-20) / CELL);
      return { cx, cy, key: cx + ',' + cy };
    }

    function atGoal(x, y) {
      const dx = x - goal.x, dy = y - goal.y;
      return dx*dx + dy*dy <= goal.r*goal.r;
    }

    // --- Akcje: 0:up, 1:down, 2:left, 3:right ---
    const ACTIONS = [
      {dx: 0,  dy:-1},
      {dx: 0,  dy: 1},
      {dx:-1,  dy: 0},
      {dx: 1,  dy: 0},
    ];

    // --- Tablica Q: Map<stateKey, Float32Array(4)>
    const Q = new Map();
    function ensureQ(key) {
      if (!Q.has(key)) Q.set(key, new Float32Array(4).fill(0));
      return Q.get(key);
    }

    function pickAction(stateKey, eps) {
      const q = ensureQ(stateKey);
      if (Math.random() < eps) {
        return Math.floor(Math.random()*4);
      } else {
        // argmax
        let bestA = 0, bestQ = q[0];
        for (let a=1;a<4;a++) if (q[a] > bestQ) { bestQ = q[a]; bestA = a; }
        return bestA;
      }
    }

    function maxQ(stateKey) {
      const q = ensureQ(stateKey);
      let m = q[0];
      for (let a=1;a<4;a++) if (q[a] > m) m = q[a];
      return m;
    }

    // --- Agenci ---
    class Agent {
      constructor() {
        this.reset();
      }
      reset() {
        this.x = start.x;
        this.y = start.y;
        this.r = 3;
        this.dead = false;
        this.reached = false;
        this.steps = 0;
      }
      draw() {
        ctx.beginPath();
        ctx.fillStyle = this.reached ? '#2ecc71' : (this.dead ? '#aa4444' : '#e0e0e0');
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    let agents = [];
    let episode = 0;
    let bestTime = null;

    function resetAgents(hard=false) {
      if (hard) { episode = 0; bestTime = null; }
      agents = new Array(POP_SIZE).fill(0).map(()=> new Agent());
      epiEl.textContent = episode;
      bestEl.textContent = bestTime == null ? '—' : bestTime + ' kroków';
    }
    resetAgents();

    // --- Aktualizacja Q: Q[s,a] += alpha * (r + gamma*maxQ(s') - Q[s,a]) ---
    function qUpdate(sKey, a, r, sNextKey, terminal=false) {
      const q = ensureQ(sKey);
      const target = terminal ? r : (r + GAMMA * maxQ(sNextKey));
      q[a] += ALPHA * (target - q[a]);
    }

    // --- Pętla symulacji i uczenia ---
    let t = 0;
    function loop() {
      drawMaze();

      if (!paused) {
        for (const ag of agents) {
          if (ag.dead || ag.reached) { ag.draw(); continue; }

          // stan i akcja
          const s = toCell(ag.x, ag.y);
          const a = pickAction(s.key, EPS);
          const move = ACTIONS[a];
          const nx = ag.x + move.dx * SPEED;
          const ny = ag.y + move.dy * SPEED;

          // nagroda i przejście
          let r = -0.001; // mały koszt kroku
          let terminal = false;

          if (collides(nx, ny, ag.r)) {
            r = -1.0;
            terminal = true;
            // aktualizacja Q
            qUpdate(s.key, a, r, s.key, true);
            ag.dead = true;
          } else {
            ag.x = nx; ag.y = ny;
            if (atGoal(ag.x, ag.y)) {
              r = +10.0;
              terminal = true;
              const sNext = toCell(ag.x, ag.y);
              qUpdate(s.key, a, r, sNext.key, true);
              ag.reached = true;
              if (bestTime == null || ag.steps < bestTime) bestTime = ag.steps;
            } else {
              const sNext = toCell(ag.x, ag.y);
              qUpdate(s.key, a, r, sNext.key, false);
            }
          }

          ag.steps++;
          if (ag.steps >= STEP_LIMIT && !ag.reached) {
            // wymuszone zakończenie epizodu
            qUpdate(s.key, a, -0.2, s.key, true);
            ag.dead = true;
          }

          ag.draw();
        }

        // warunek końca epizodu
        const epDone = agents.every(a=> a.dead || a.reached);
        if (epDone) {
          episode++;
          epiEl.textContent = episode;
          bestEl.textContent = bestTime == null ? '—' : bestTime + ' kroków';

          // zmniejsz epsilon (ale nie poniżej 0.02)
          EPS = Math.max(0.02, EPS * EPS_DECAY);
          epsEl.textContent = EPS.toFixed(2);

          // reset agentów
          for (const a of agents) a.reset();
          t = 0;
        } else {
          t++;
        }
      } else {
        // rysuj agentów bez aktualizacji
        for (const ag of agents) ag.draw();
      }

      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html> -->






<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>SARSA: 100 kropek w labiryncie</title>
  <style>
    body { font-family: system-ui, sans-serif; background:#111; color:#eee; display:flex; gap:24px; }
    #ui { width: 320px; }
    canvas { background:#222; border:1px solid #444; }
    .pill { background:#333; padding:6px 10px; border-radius:6px; display:inline-block; margin-right:8px; }
    label { display:block; margin:8px 0 4px; font-size:14px; color:#ccc; }
    input[type=range] { width:100%; }
    button { padding:8px 12px; background:#444; color:#eee; border:none; cursor:pointer; }
    button:hover { background:#555; }
    .hint { color:#aaa; font-size:13px; }
  </style>
</head>
<body>
  <div id="ui">
    <h2>SARSA w labiryncie</h2>
    <div><span class="pill">Populacja: <b id="pop">100</b></span><span class="pill">Epizod: <b id="epi">0</b></span></div>
    <div><span class="pill">Epsilon: <b id="eps">0.30</b></span><span class="pill">Najlepszy czas: <b id="best">—</b></span></div>

    <label>Rozmiar komórki siatki (px)</label>
    <input id="cellSize" type="range" min="10" max="40" value="20">
    <div>Wartość: <b id="cellSizeVal">20</b></div>

    <label>Uczenie (alpha)</label>
    <input id="alpha" type="range" min="1" max="100" value="25">
    <div>Wartość: <b id="alphaVal">0.25</b></div>

    <label>Zdyskontowanie (gamma)</label>
    <input id="gamma" type="range" min="50" max="99" value="92">
    <div>Wartość: <b id="gammaVal">0.92</b></div>

    <label>Epsilon początkowy</label>
    <input id="epsInit" type="range" min="0" max="100" value="30">
    <div>Wartość: <b id="epsInitVal">0.30</b></div>

    <label>Spadek eps po epizodzie</label>
    <input id="epsDecay" type="range" min="90" max="100" value="98">
    <div>Wartość: <b id="epsDecayVal">0.98</b> <span class="hint">(mnożnik)</span></div>

    <div style="margin-top:12px;">
      <button id="restart">Restart</button>
      <button id="pause">Pauza</button>
      <button id="clearQ">Wyczyść Q</button>
    </div>

    <p class="hint" style="margin-top:12px;">
      SARSA: Q[s,a] ← Q[s,a] + α [ r + γ Q[s’,a’] − Q[s,a] ]  
      czyli aktualizacja na podstawie faktycznie wybranej akcji w następnym stanie.
    </p>
  </div>

  <canvas id="cv" width="720" height="520"></canvas>

  <script>
    // --- Parametry ---
    const W = 720, H = 520;
    const POP_SIZE = 100;
    const SPEED = 2.0;
    const STEP_LIMIT = 2000;

    const start = { x: 50, y: H - 50 };
    const goal  = { x: W - 70, y: 60, r: 18 };

    const cv = document.getElementById('cv');
    const ctx = cv.getContext('2d');

    const epiEl = document.getElementById('epi');
    const popEl = document.getElementById('pop');
    const epsEl = document.getElementById('eps');
    const bestEl = document.getElementById('best');
    const cellSizeEl = document.getElementById('cellSize');
    const cellSizeValEl = document.getElementById('cellSizeVal');
    const alphaEl = document.getElementById('alpha');
    const alphaValEl = document.getElementById('alphaVal');
    const gammaEl = document.getElementById('gamma');
    const gammaValEl = document.getElementById('gammaVal');
    const epsInitEl = document.getElementById('epsInit');
    const epsInitValEl = document.getElementById('epsInitVal');
    const epsDecayEl = document.getElementById('epsDecay');
    const epsDecayValEl = document.getElementById('epsDecayVal');

    const btnRestart = document.getElementById('restart');
    const btnPause   = document.getElementById('pause');
    const btnClearQ  = document.getElementById('clearQ');

    popEl.textContent = POP_SIZE;

    let CELL = +cellSizeEl.value;
    let ALPHA = +alphaEl.value / 100;
    let GAMMA = +gammaEl.value / 100;
    let EPS = +epsInitEl.value / 100;
    let EPS_DECAY = +epsDecayEl.value / 100;

    cellSizeValEl.textContent = CELL;
    alphaValEl.textContent = ALPHA.toFixed(2);
    gammaValEl.textContent = GAMMA.toFixed(2);
    epsInitValEl.textContent = EPS.toFixed(2);
    eps_decay_display();
    function eps_decay_display(){ epsDecayValEl.textContent = EPS_DECAY.toFixed(2); epsEl.textContent = EPS.toFixed(2); }

    cellSizeEl.oninput = () => { CELL = +cellSizeEl.value; cellSizeValEl.textContent = CELL; };
    alphaEl.oninput = () => { ALPHA = +alphaEl.value/100; alphaValEl.textContent = ALPHA.toFixed(2); };
    gammaEl.oninput = () => { GAMMA = +gammaEl.value/100; gammaValEl.textContent = GAMMA.toFixed(2); };
    epsInitEl.oninput = () => { EPS = +epsInitEl.value/100; epsInitValEl.textContent = EPS.toFixed(2); eps_decay_display(); };
    epsDecayEl.oninput = () => { EPS_DECAY = +epsDecayEl.value/100; eps_decay_display(); };

    btnClearQ.onclick = () => { Q.clear(); };
    btnRestart.onclick = () => { resetAgents(true); EPS = +epsInitEl.value/100; eps_decay_display(); };
    let paused = false;
    btnPause.onclick = () => { paused = !paused; btnPause.textContent = paused ? 'Wznów' : 'Pauza'; };

    // --- Labirynt ---
    const walls = [
      {x: 0, y: 0, w: W, h: 20},
      {x: 0, y: H-20, w: W, h: 20},
      {x: 0, y: 0, w: 20, h: H},
      {x: W-20, y: 0, w: 20, h: H},
      {x: 120, y: 80, w: 480, h: 20},
      {x: 120, y: 80, w: 20, h: 300},
      {x: 120, y: 360, w: 400, h: 20},
      {x: 500, y: 140, w: 20, h: 240},
      {x: 260, y: 140, w: 260, h: 20},
      {x: 260, y: 200, w: 20, h: 160},
      {x: 320, y: 260, w: 180, h: 20},
    ];

    function drawMaze() {
      ctx.fillStyle = '#333';
      ctx.fillRect(0,0,W,H);
      ctx.beginPath(); ctx.fillStyle = '#2ecc71'; ctx.arc(goal.x, goal.y, goal.r, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.fillStyle = '#3498db'; ctx.arc(start.x, start.y, 6, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#777'; for (const w of walls) ctx.fillRect(w.x, w.y, w.w, w.h);
    }

    function collides(x, y, r=5) {
      for (const w of walls) {
        const nx = Math.max(w.x, Math.min(x, w.x + w.w));
        const ny = Math.max(w.y, Math.min(y, w.y + w.h));
        const dx = x - nx, dy = y - ny;
        if (dx*dx + dy*dy <= r*r) return true;
      }
      if (x < 20+r || x > W-20-r || y < 20+r || y > H-20-r) return true;
      return false;
    }

    // --- Dyskretyzacja stanu ---
    function toCell(x, y) {
      const gx = Math.max(20, Math.min(x, W-20-1));
      const gy = Math.max(20, Math.min(y, H-20-1));
      const cx = Math.floor((gx-20) / CELL);
      const cy = Math.floor((gy-20) / CELL);
      return { cx, cy, key: cx + ',' + cy };
    }

    function atGoal(x, y) {
      const dx = x - goal.x, dy = y - goal.y;
      return dx*dx + dy*dy <= goal.r*goal.r;
    }

    // --- Akcje ---
    const ACTIONS = [
      {dx: 0, dy:-1}, // up
      {dx: 0, dy: 1}, // down
      {dx:-1, dy: 0}, // left
      {dx: 1, dy: 0}, // right
    ];

    // --- Tablica Q ---
    const Q = new Map();
    function ensureQ(key) {
      if (!Q.has(key)) Q.set(key, new Float32Array(4).fill(0));
      return Q.get(key);
    }

    function pickAction(stateKey, eps) {
      const q = ensureQ(stateKey);
      if (Math.random() < eps) {
        return Math.floor(Math.random()*4);
      } else {
        let bestA = 0, bestQ = q[0];
        for (let a=1;a<4;a++) if (q[a] > bestQ) { bestQ = q[a]; bestA = a; }
        return bestA;
      }
    }

    // --- Agent ---
    class Agent {
      constructor() { this.reset(); }
      reset() {
        this.x = start.x; this.y = start.y;
        this.r = 3; this.dead = false; this.reached = false;
        this.steps = 0;
        const s = toCell(this.x, this.y);
        this.state = s.key;
        this.action = pickAction(this.state, EPS);
      }
      draw() {
        ctx.beginPath();
        ctx.fillStyle = this.reached ? '#2ecc71' : (this.dead ? '#aa4444' : '#e0e0e0');
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    let agents = [];
    let episode = 0;
    let bestTime = null;

    function resetAgents(hard=false) {
      if (hard) { episode = 0; bestTime = null; }
      agents = new Array(POP_SIZE).fill(0).map(()=> new Agent());
      epiEl.textContent = episode;
      bestEl.textContent = bestTime == null ? '—' : bestTime + ' kroków';
    }
    resetAgents();

    // --- Aktualizacja SARSA ---
    function sarsaUpdate(sKey, a, r, sNextKey, aNext, terminal=false) {
      const q = ensureQ(sKey);
      const qNext = ensureQ(sNextKey);
      const target = terminal ? r : (r + GAMMA * qNext[aNext]);
      q[a] += ALPHA * (target - q[a]);
    }

    // --- Pętla ---
    let t = 0;
    function loop() {
      drawMaze();

      if (!paused) {
        for (const ag of agents) {
          if (ag.dead || ag.reached) { ag.draw(); continue; }

          const move = ACTIONS[ag.action];
          const nx = ag.x + move.dx * SPEED;
          const ny = ag.y + move.dy * SPEED;

          let r = -0.001;
          let terminal = false;

          if (collides(nx, ny, ag.r)) {
            r = -1.0; terminal = true;
            sarsaUpdate(ag.state, ag.action, r, ag.state, ag.action, true);
            ag.dead = true;
          } else {
            ag.x = nx; ag.y = ny;
            if (atGoal(ag.x, ag.y)) {
              r = +10.0; terminal = true;
              const sNext = toCell(ag.x, ag.y);
              sarsaUpdate(ag.state, ag.action, r, sNext.key, ag.action, true);
              ag.reached = true;
              if (bestTime == null || ag.steps < bestTime) bestTime = ag.steps;
            } else {
              const sNext = toCell(ag.x, ag.y);
              const aNext = pickAction(sNext.key, EPS);
              sarsaUpdate(ag.state, ag.action, r, sNext.key, aNext, false);
              ag.state = sNext.key;
              ag.action = aNext;
            }
          }

          ag.steps++;
          if (ag.steps >= STEP_LIMIT && !ag.reached) {
            sarsaUpdate(ag.state, ag.action, -0.2, ag.state, ag.action, true);
            ag.dead = true;
          }

          ag.draw();
        }

        const epDone = agents.every(a=> a.dead || a.reached);
        if (epDone) {
          episode++;
          epiEl.textContent = episode;
          bestEl.textContent = bestTime == null ? '—' : bestTime + ' kroków';
          EPS = Math.max(0.02, EPS * EPS_DECAY);
          epsEl.textContent = EPS.toFixed(2);
          for (const a of agents) a.reset();
          t = 0;
        } else { t++; }
      } else {
        for (const ag of agents) ag.draw();
      }

      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>

